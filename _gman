#compdef gman

_gman() {
    local curcontext="$curcontext" state line ret=1
    typeset -A opt_args

    # Count how many positional arguments we've already seen (excluding flags)
    local -a positional_args
    local i
    for ((i = 2; i <= $#words; i++)); do
        if [[ "$words[$i]" != -* ]]; then
            positional_args+=("$words[$i]")
        fi
    done

    # If current word starts with - and we're past the program argument,
    # prioritize flags from the target program's man page
    if [[ $CURRENT -gt 2 && $words[$CURRENT] == -* && ${#positional_args} -ge 1 ]]; then
        _gman_flags_from_man "$positional_args[1]" && return 0
    fi

    _arguments -C \
        '(-c --case-sensitive)'{-c,--case-sensitive}'[Case sensitive search]' \
        '(-h --help)'{-h,--help}'[Show help information]' \
        '(-V --version)'{-V,--version}'[Show version]' \
        '1:program:->program' \
        '2:search term:->term' \
        '*::arguments:_default' \
        && return 0

    case $state in
        program)
            _gman_programs
            return 0
            ;;
        term)
            # Get the program name from positional args
            local program=""
            for ((i = 2; i <= $#words; i++)); do
                if [[ "$words[$i]" != -* && "$words[$i]" != "$words[$CURRENT]" ]]; then
                    program="$words[$i]"
                    break
                fi
            done

            if [[ -n "$program" ]]; then
                _gman_flags_from_man "$program" && return 0
            fi
            _default
            ;;
    esac

    return ret
}

_gman_programs() {
    local -a programs

    # Get list of available man pages (section 1 and 8 - user commands and system admin)
    if (( $+commands[apropos] )); then
        programs=(${(f)"$(apropos -s 1,8 . 2>/dev/null | cut -d' ' -f1 | cut -d'(' -f1)"})
    fi

    # Fallback to commands in PATH if apropos didn't work
    if [[ ${#programs} -eq 0 ]]; then
        programs=(${(k)commands})
    fi

    _describe 'man pages' programs
}

_gman_flags_from_man() {
    local program=$1
    local -a items
    local item

    # Extract flags and subcommands from the man page
    if (( $+commands[man] )); then
        local manpage=$(man -P cat "$program" 2>/dev/null)

        # Extract flags (starting with - or --)
        while IFS= read -r item; do
            if [[ -n "$item" && "$item" =~ ^--?[a-zA-Z] ]]; then
                items+=("${item}:flag")
            fi
        done < <(echo "$manpage" |
            grep -oE '(^|[[:space:],])(--?[a-zA-Z0-9][-a-zA-Z0-9_]*)' |
            sed 's/^[[:space:],]*//' |
            sort -u)

        # Extract subcommands (e.g., git-add, git-commit)
        # Look for patterns like "program-subcommand"
        while IFS= read -r item; do
            if [[ -n "$item" ]]; then
                items+=("${item}:subcommand")
            fi
        done < <(echo "$manpage" |
            grep -oE "${program}-[a-z][a-z0-9-]+" |
            sed "s/^${program}-//" |
            sort -u)

        # Remove duplicates and limit results
        items=(${(u)items})
        items=(${items[1,100]})

        if [[ ${#items} -gt 0 ]]; then
            _describe "search term from $program man page" items
            return 0
        fi
    fi
    return 1
}

_gman "$@"
